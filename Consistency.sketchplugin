// Creates a shared object for the selected layers (cmd control option m)


@import 'inventory.js'

var doc = context.document;

var layer = selection.firstObject();
var pass = true;
var selectedLayers = selection;


function areOfEqualClass (layers) {
    var baseClass = layers[0].className();
    for (var i = 0; i < layers.count(); i++) {
        if (layers[i].className() != baseClass) {
            return false;
        }
    }
    return true;
}

if (selectedLayers.count() > 1) {
    pass = areOfEqualClass(selectedLayers);
}

if (pass) {
    if(layer) {
        if (!layer.isSymbol()) {
            if (true) {
                if (layer.className() == "MSShapeGroup") {

                    var layerStyle;
                    var selection = selectLayerStyle();
                    var sharedStyles = doc.documentData().layerStyles();
                    var hasSharedStyle = layer.style().sharedObjectID() != null;

                    if (selection){
                        if(selection[0] == 1000) {
                            if (selection[1] == -1) {

                               // create new text style
                               layerStyle = sharedStyles.addSharedStyleWithName_firstInstance(selection[2], layer.style());
                               doc.showMessage("Style created")
                            } else {

                                // apply existing style
                                var index = selection[1];
                                layerStyle = sharedStyles.objects().objectAtIndex(index);
                            }

                            // style all other layers
                            if (!hasSharedStyle) {
                                var result = styleAllLayersBasedOnLayerWithLayerStyle(layer, layerStyle);
                                log(result)
                                doc.showMessage("Style applied to " + result.count() + " instances");
                            } else {
                                // apply self
                                styleLayer(layer, layerStyle);
                                doc.showMessage("Style applied to selected layer");
                            }
                        }
                    } else {
                        var name = getUserInput("New Layer Style");
                        if (name){
                            // create new layer style
                            sharedStyles = doc.documentData().layerStyles();
                            layerStyle = sharedStyles.addSharedStyleWithName_firstInstance(name, layer.style());

                            styleAllLayersBasedOnLayerWithLayerStyle(layer, layerStyle);

                            doc.showMessage("Style created")
                        }
                    }
                } else if (layer.className() == "MSTextLayer") {

                    var textStyle;
                    var textStyles = doc.documentData().layerTextStyles();
                    var referenceStyle = layer.style().textStyle();

                    var hasSharedStyle = layer.style().sharedObjectID() != null;
                    log(hasSharedStyle)

                    var selectIndex = 0;

                    if (textStyles) {
                        // get index
                        for (var i = 0; i < textStyles.objects().count(); i++) {
                            if (layer.style().sharedObjectID() == textStyles.objects().objectAtIndex(i).objectID()) {
                                selectIndex = i;
                            }
                        }
                    }

                    var selection = selectTextStyle(selectIndex);

                    // todo if it has style and create a new one, dont apply
                    if (selection){
                        if (selection[0] == 1000) {
                            if (selection[1] == -1) {
                               // create new text style
                               textStyle = textStyles.addSharedStyleWithName_firstInstance(selection[2], layer.style());
                               doc.showMessage("Added new text style");
                            } else {
                                // apply existing style
                                var index = selection[1];
                                textStyle = textStyles.objects().objectAtIndex(index);
                            }
                            // style all other text layers
                            if (!hasSharedStyle) {
                                var result = styleAllTextLayersBasedOnLayerWithTextStyle(layer, textStyle);
                                doc.showMessage("Style applied to " + result.count() + " instances");
                            } else {
                                // apply self
                                styleLayer(layer, textStyle);
                                doc.showMessage("Style applied to selected layer");
                            }
                        }
                    } else {
                        var name = getUserInput("New Text Style");
                        if (name){

                            // create new text style
                           textStyles = doc.documentData().layerTextStyles()
                           var textStyle = textStyles.addSharedStyleWithName_firstInstance(name, layer.style());

                           styleAllTextLayersBasedOnLayerWithTextStyle(layer, textStyle);

                           doc.showMessage("Style created")
                        }
                    }
                } else if (layer.className() == "MSLayerGroup") {
                    var name = getUserInput("New Symbol");
                    if (name){

                        // get equal layers
                        var layers = getEqualLayers(layer, doc.currentPage().children());

                        // add symbol
                        symbols = doc.documentData().layerSymbols()
                        var symbol = symbols.addSymbolWithName_firstInstance(name, layer);

                        // dump(symbols)
                        for (var i = 0; i < layers.count(); i++) {
                            symbol.registerInstance(layers.objectAtIndex(i));
                            layers.objectAtIndex(i).setName(symbol.name());

                            doc.showMessage("Converted " + layers.count() + " layers to symbols.")
                        }

                        // getPageByName("Symbols").addLayers([layer]);
                        //
                        var currentPage = doc.currentPage();

                        // generate symbol sheet
                        addSymbolsSheetToPage("✴️ Symbols");

                        // reset page
                        doc.setCurrentPage(currentPage);

                    }
                }
            } else {
                doc.showMessage("Can’t add another style to this layer.")
            }
        } else {
            // get the symbols name
            var symbolName = doc.documentData().layerSymbols().symbolWithID(layer.sharedObjectID()).name()

            // ask for a new name
            var name = [doc askForUserInput:"Duplicate Symbol as…" initialValue:symbolName]);

            if (name){

                // unlink symbol from group
                layer.unregisterAsSymbolIfNecessary();

                // add the symbol
                symbols = doc.documentData().layerSymbols();
                symbols.addSymbolWithName_firstInstance(name, layer);
            }
            doc.showMessage("Duplicated Symbol");
        }
    }
} else {
    doc.showMessage("Please make sure that you select layers of the same type.");
}

doc.reloadInspector();

function addSymbolsSheetToPage (pageName) {

    var symbols = doc.documentData().layerSymbols().objects();
    var page = getPageByName(pageName);
    page.removeAllLayers();

    var artboard = MSArtboardGroup.new();
    var frame = artboard.frame();
    frame.setX(0);
    frame.setY(0);
    frame.setConstrainProportions(false);
    frame.setWidth(800)
    frame.setHeight(500)
    page.addLayers([artboard])


    for (var i = 0; i < symbols.count(); i++) {

        // get symbol reference
        var symbolRef = symbols.objectAtIndex(i);

        // add layer from symbol to document
        var symbol = symbols.objectAtIndex(i).newInstance();

        // set name
        symbol.setName(symbolRef.name());

        // add symbol to page
        artboard.addLayers([symbol]);
    }
    layout(artboard);
}

function layout (artboard) {

    // ui/navigation/header
    // ui/navigation/header/default
    //

    var name;
    var moduleName;
    var prevName;
    var layer;
    var layers = getLayersSortedByName(artboard.layers());

    var padding = 200;
    var nextX = padding;
    var nextY = 0;
    var gridX = 100;
    var gridY = 200;
    var maxX = 0;
    var maxY = 0;
    var lines = [];

    for (var i = 0; i < layers.length; i++) {
        layer = layers[i].layer;
        name = layer.name();
        moduleName = name.substr(0, name.lastIndexOf("/") + 1);

        if (layer.frame().height() > maxY) maxY = layer.frame().height();

        if (moduleName != prevName) {
            nextX = padding;
            nextY += maxY + gridY;
            maxY = 0;
            prevName = moduleName;

            // draw a separator
            var line = addLine(artboard);
            line.frame().setX(padding);
            line.frame().setY(nextY - gridY / 4);
            line.frame().setWidth(100);
            lines.push(line);

            // add module name as text layer
            var text = com.getflourish.common.addTextLayer(artboard, moduleName.toUpperCase());

            var labelTextStyleName = "Style Inventory / Label";
            var style = getTextStyleByName(labelTextStyleName);
            if (style != null) {
                // apply style
                styleLayer(text, style);
            } else {
                doc.showMessage("style nzll")
                // create style
                text.setFontSize(15);
                text.setFontPostscriptName("HelveticaNeue-Bold");
                text.setCharacterSpacing(2);

                // color
                var color = MSColor.colorWithSVGString("#777777");

                // set text style
                text.setTextColor(color);

                // add the new text style
                //var textStyles = doc.documentData().layerTextStyles();
                //textStyles.addSharedStyleWithName_firstInstance(labelTextStyleName, text.style());
            }

            text.frame().setY(nextY - gridY / 4 - 24);
            text.frame().setX(padding);
        } else {
            nextX += gridX;
        }
        layer.frame().setX(nextX);
        layer.frame().setY(nextY);

        var r = layer.frame().x() + layer.frame().width();
        if (r > maxX) maxX = r;

        nextX += layer.frame().width();
    }

    artboard.frame().setHeight(nextY + padding + maxY)
    artboard.frame().setWidth(maxX + padding)

    // resize separators
    for (var i = 0; i < lines.length; i++) {
        lines[i].frame().setWidth(maxX);
    }

    // add background
    var bg = com.getflourish.common.addSolidBackground(artboard, "#353535");
    doc.currentPage().deselectAllLayers();
    bg.setIsSelected(true);
    com.getflourish.utils.sendToBack();
    bg.setIsLocked(true);
}
function addLine (target) {
    var black = MSColor.colorWithSVGString("#000000");
    black.alpha = 0.15;
    var line = com.getflourish.colors.addColorShape(target, black, 100, 1);
    return line;
}

function getLayersSortedByName (layers) {

    var layer;
    var layersMeta = [];

    for (var i = 0; i < layers.count(); i++) {

        layer = layers.objectAtIndex(i);

        layersMeta.push({
            "name": layer.name(),
            "layer": layer
        });
    }

    return layersMeta.sort(sortName);
}

function sortName (_a, _b) {
    var a = _a.name;
    var b = _b.name;

    return naturalSort(a, b);
}

/*
 * Natural Sort algorithm for Javascript - Version 0.7 - Released under MIT license
 * Author: Jim Palmer (based on chunking idea from Dave Koelle)
 */

 function naturalSort (a, b) {
    var re = /(^-?[0-9]+(\.?[0-9]*)[df]?e?[0-9]?$|^0x[0-9a-f]+$|[0-9]+)/gi,
        sre = /(^[ ]*|[ ]*$)/g,
        dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/,
        hre = /^0x[0-9a-f]+$/i,
        ore = /^0/,
        i = function(s) { return naturalSort.insensitive && (''+s).toLowerCase() || ''+s },
        // convert all to strings strip whitespace
        x = i(a).replace(sre, '') || '',
        y = i(b).replace(sre, '') || '',
        // chunk/tokenize
        xN = x.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
        yN = y.replace(re, '\0$1\0').replace(/\0$/,'').replace(/^\0/,'').split('\0'),
        // numeric, hex or date detection
        xD = parseInt(x.match(hre)) || (xN.length != 1 && x.match(dre) && Date.parse(x)),
        yD = parseInt(y.match(hre)) || xD && y.match(dre) && Date.parse(y) || null,
        oFxNcL, oFyNcL;
    // first try and sort Hex codes or Dates
    if (yD)
        if ( xD < yD ) return -1;
        else if ( xD > yD ) return 1;
    // natural sorting through split numeric strings and default strings
    for(var cLoc=0, numS=Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
        // find floats not starting with '0', string or 0 if not defined (Clint Priest)
        oFxNcL = !(xN[cLoc] || '').match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
        oFyNcL = !(yN[cLoc] || '').match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
        // handle numeric vs string comparison - number < string - (Kyle Adams)
        if (isNaN(oFxNcL) !== isNaN(oFyNcL)) { return (isNaN(oFxNcL)) ? 1 : -1; }
        // rely on string comparison if different types - i.e. '02' < 2 != '02' < '2'
        else if (typeof oFxNcL !== typeof oFyNcL) {
            oFxNcL += '';
            oFyNcL += '';
        }
        if (oFxNcL < oFyNcL) return -1;
        if (oFxNcL > oFyNcL) return 1;
    }
    return 0;
}

function getUserInput(placeholder) {
    var name = [doc askForUserInput:"Consistency" initialValue:placeholder]);
    return name;
}

function createSelect (msg, items, selectedItemIndex){
    selectedItemIndex = selectedItemIndex || 0

    var accessory = [[NSComboBox alloc] initWithFrame:NSMakeRect(0,0,200,25)]
    [accessory addItemsWithObjectValues:items]
    [accessory selectItemAtIndex:selectedItemIndex]

    var alert = [[NSAlert alloc] init]
    [alert setMessageText:msg]
    [alert addButtonWithTitle:'OK']
    [alert addButtonWithTitle:'Cancel']
    [alert setAccessoryView:accessory]

    var responseCode = [alert runModal]
    var sel = [accessory indexOfSelectedItem]
    var value = [accessory stringValue]

    return [responseCode, sel, value]
}

function getLayersByTextStyle (textStyle, scope) {
    var predicate = NSPredicate.predicateWithFormat("(style.textStyle != NULL) && (FUNCTION(style.textStyle, 'isEqualForSync:asPartOfSymbol:', %@, nil) == YES)", textStyle);
    // query page layers
    var queryResult = scope.filteredArrayUsingPredicate(predicate);

    return queryResult;
}

function getLayersByLayerStyle (layerStyle, scope) {
    var predicate = NSPredicate.predicateWithFormat("(style.fill != NULL) && (FUNCTION(style.fill, 'isEqualForSync:asPartOfSymbol:', %@, nil) == YES)", layerStyle.fill());
    // query page layers
    var queryResult = scope.filteredArrayUsingPredicate(predicate);

    return queryResult;
}

function getLayersBySize (referenceLayer, scope) {
    var predicate = NSPredicate.predicateWithFormat("(frame != NULL) && frame.width == %@ && frame.height == %@ && className == %@", referenceLayer.frame().width(), referenceLayer.frame().height());
    var queryResult = scope.filteredArrayUsingPredicate(predicate);

    return queryResult;
}

function getEqualLayers (referenceLayer, scope) {
    var predicate = NSPredicate.predicateWithFormat("(FUNCTION(self, 'isEqualForSync:asPartOfSymbol:', %@, nil) == YES)", context.selection[0]);
    var queryResult = scope.filteredArrayUsingPredicate(predicate);
    return queryResult;
}


function styleAll(layers, style) {
    for (var i = 0; i < layers.count(); i++) {
        styleLayer(layers[i], style);
    }
}

function styleLayer(layer, style) {
    layer.setStyle(style.newInstance());
}

function styleAllTextLayersBasedOnLayerWithTextStyle (layer, textStyle) {

    // get all text layers that match the style
    var layers = getLayersByTextStyle(layer.style().textStyle(), doc.currentPage().children());
    styleAll(layers, textStyle);
    return layers;
}

function styleAllLayersBasedOnLayerWithLayerStyle (layer, layerStyle) {

    // get all text layers that match the style
    var layers = getLayersByLayerStyle(layer.style(), doc.currentPage().children());
    styleAll(layers, layerStyle);
    return layers;
}


function selectTextStyle (preselect) {
    var preselect = preselect || 0;
    var textStyles = [];
    var textItems = [];

    var selection;

    var styles = doc.documentData().layerTextStyles().objects();
    if (styles.count() != 0) {
        for (var i = 0; i < styles.count(); i++) {
          var style = styles.objectAtIndex(i);
            textStyles.push({
                "textStyle": style,
                "name": style.name()
            });
            textItems.push(style.name());
        }
        if (textItems) selection = createSelect("Select a text style or create a new one", textItems, preselect);
    } else {
        return;
    }
    return selection;
}

function selectLayerStyle () {
    var layerStyles = [];
    var layerStyleItems = [];

    var selection;

    var styles = doc.documentData().layerStyles().objects();
    if (styles.count() != 0) {
        for (var i = 0; i < styles.count(); i++) {
          var style = styles.objectAtIndex(i);
            layerStyles.push({
                "layerStyle": style,
                "name": style.name()
            });
            layerStyleItems.push(style.name());
        }
        if (layerStyleItems) selection = createSelect("Select a style or create a new one", layerStyleItems, 0);
    } else {
        return;
    }
    return selection;
}

// Returns the page if it exists or creates a new page
function getPageByName (name) {
    for (var i = 0; i < doc.pages()
        .count(); i++) {
        var page = doc.pages()
            .objectAtIndex(i);
        if (page.name() == name) {
            doc.setCurrentPage(page);
            return page;
        }
    }
    var page = addPage(name);
    return page;
}

// Adds a new page to the document
function addPage (name) {
    // look for existing style sheet, otherwise create a new page with the styles
    var page = doc.addBlankPage();
    page.setName(name);
    doc.setCurrentPage(page);
    // my.common.refreshPage();
    return page;
}

function getTextStyleByName(name) {
    var textStyle;
    var textStyles = doc.documentData().layerTextStyles();

    if (textStyles) {
        // get index
        for (var i = 0; i < textStyles.objects().count(); i++) {
            if (textStyles.objects().objectAtIndex(i).name() == name) {
                return textStyles.objects().objectAtIndex(i);
            }
        }
    }
    return null;
}